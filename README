Copyright 2010 Pat M. Lasswell GPLv3

Contents
  1. Differences From R5RS
    1.1 Features Not Supported
    1.2 Extensions
      1.2.1 Block Quote
      1.2.2 Dotted Symbols
      1.2.3 Javascript/Scheme Interleaving

  2. Usage
    2.1 Requirements
    2.2 Client
    2.3 Server

  3. Components
    3.1 Moosky
    3.2 Moosky.Cons
    3.3 Moosky.read
    3.4 Moosky.compile
    3.5 Moosky.Top
    3.6 Moosky.TokenClasses 

  4. Implementation
    4.1 Frames and Scope
    4.2 Internal Representation
    4.3 Object Code
    4.4 Relationship With Javascript

  5. TODO


1. Differences From R5RS


1.1 Features Not Supported

Continuations
Ports
Numeric Tower


1.2 Extensions


1.2.1 Block Quote

Moosky provides a block quoting mechanism.  While Scheme allows
multiline quotes, there are annoyances with newlines at the starts and
ends of long blocks.  I.e.

(define (foo a b)
  (bar "Hello, World!

How are you today?")

is perfectly acceptible, but is a little unsightly in that the first
line and last lines are muddled up with code.  The extension syntax
provides strings delimited by #<<\n and \n>>#.  The prior example
would be written

(define (foo a b)
  (bar #<<
Hello, World!

How are you today?
>>#)

It's a small thing, but it provides for a slightly neater way to
include large blocks of text into a scheme program.

One final thing to note is that the empty string is 

#<<

>>#

since each delimiter has a newline.


1.2.2 Dotted Symbols

In R5RS foo.bar is an acceptible symbol with no special handling.  In
Moosky, to allow easy access to Javascript objects, symbols with a '.'
in them are assumed to refer to objects in the Javascript namespace.
Hence 'Hello, World!' can be as simple as

(window.alert "Hello, World!")


1.2.3 Javascript/Scheme Interleaving

Javascript can be inserted directly into Scheme code by quoting with
braces.  Both simple inline quotes and extended multiline quotes are
supported.  Furthermore, Scheme can be inserted into these blocks
using the backquote.

Single line Javscript starts with an open brace in the second or
subsequent column.  

(define foo { new Foo() })

Nested braces are not allowed.  Thus

(map { function(a) { return a.split(','); } } args)

won't fly, but

(map #{ function(a) { return a.split(','); } }# args)

is just fine.

To interpolate bits of Scheme into Javascript, use @:

(map #{ function(a) { return @(car a).split(','); } }# args)

or 

(define foo { new Foo(@car) })

5. TODO

4.2.4
do

4.2.5
delay

4.2.6
quasiquote
`

4.3.1
let-syntax
letrec-syntax

4.3.2
syntax-rules

5.3
define-syntax

6.3.2
list-tail
list-ref
memq
memv
member
assq
assv
assoc

6.3.3
symbol?
symbol->string
string->symbol

6.3.4
character literals
char?
char=?
char<?
char>?
char<=?
char>=?
char-ci=?
char-ci<?
char-ci>?
char-ci<=?
char-ci>=?
char-alphabetic?
char-numeric?
char-whitespace?
char-upper-case?
char-lower-case?
char->integer
integer->char
char-upcase
char-downcase

6.3.5
string?
make-string
string
string-length
string-ref
string-set!
string=?
string<?
string>?
string<=?
string>=?
string-ci=?
string-ci<?
string-ci>?
string-ci<=?
string-ci>=?
substring
string-append
string->list
list->string
string-copy
string-fill!

6.3.6
vector?
make-vector
vector
vector-length
vector-ref
vector-set!
vector->list
list->vector

6.4
procedure?
apply
map
for-each
force

6.5
eval
scheme-report-environment
null-environment
interaction-environment
